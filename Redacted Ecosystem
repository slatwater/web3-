// ==UserScript==
// @name         Auto Click on Redacted Airways with Retry for Continue Button
// @namespace    http://tampermonkey.net/
// @version      2.3
// @description  自动点击Redacted Airways页面的指定按钮并处理弹出窗口，全局查找 CONTINUE 按钮并增加重试机制，确保对FOLLOW, LIKE, RETWEET按钮的点击生效
// @match        https://quest.redactedairways.com/home
// @grant        none
// @run-at       document-idle
// ==/UserScript==

(function() {
    'use strict';

    let buttonClickCount = 0; // 记录已点击按钮次数
    let loopCount = 0; // 记录循环次数

    // 随机延迟函数，避免过快操作
    function randomDelay(min, max) {
        return new Promise(resolve => setTimeout(resolve, Math.floor(Math.random() * (max - min + 1)) + min));
    }

    // 等待元素出现并可见的函数（支持 XPath）
    function waitForElementVisible(selector, timeout = 20000, retryInterval = 2000, maxRetries = 10) {
        return new Promise((resolve, reject) => {
            let retries = 0;
            const startTime = Date.now();
            (function check() {
                let element;
                if (selector.startsWith('/')) {
                    element = document.evaluate(selector, document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue;
                } else {
                    element = document.querySelector(selector);
                }

                if (element && element.offsetParent !== null) {
                    resolve(element);
                } else if (Date.now() - startTime > timeout || retries >= maxRetries) {
                    reject(new Error(`Timeout: Element ${selector} not found after ${retries} retries`));
                } else {
                    retries++;
                    setTimeout(check, retryInterval);  // 每次重试之间的延迟
                }
            })();
        });
    }

    // 判断元素是否位于屏幕中央
    function isElementInExactCenter(element) {
        const rect = element.getBoundingClientRect();
        const screenHeight = window.innerHeight;
        const screenWidth = window.innerWidth;

        const isVerticallyCentered = (rect.top >= screenHeight * 0.25 && rect.bottom <= screenHeight * 0.75);
        const isHorizontallyCentered = (rect.left >= screenWidth * 0.35 && rect.right <= screenWidth * 0.65);

        return isVerticallyCentered && isHorizontallyCentered;
    }

    // 点击第一个元素并触发页面变化
    async function clickFirstElement() {
        const firstElement = await waitForElementVisible('//*[@id="social-quests"]/section[1]/div[1]/div[2]');
        if (firstElement) {
            console.log('点击了第一个元素，触发页面变化...');
            firstElement.click();
            await randomDelay(2000, 4000);  // 增加延迟，等待页面变化
        } else {
            console.error('未找到第一个元素');
        }
    }

    // 处理弹出的窗口
    async function handlePopup() {
        try {
            const popup = await waitForElementVisible('//*[@id="social-quests"]/div[1]/div[2]/div', 5000);
            if (popup) {
                console.log('小窗口已弹出，处理其中的按钮...');

                const popupButtons = Array.from(popup.querySelectorAll('button')).filter(button =>
                    ['FOLLOW', 'LIKE', 'RETWEET'].some(text => button.innerText.toUpperCase().includes(text))
                );

                for (let button of popupButtons) {
                    console.log(`尝试点击小窗口中的按钮: ${button.innerText}`);
                    await ensureButtonClick(button);
                    await randomDelay(1000, 3000);  // 点击后添加延迟
                }

                // 等待并点击 "CONTINUE" 按钮
                await waitForAndClickContinue();
                return true;
            }
        } catch (error) {
            console.log('小窗口未弹出');
        }
        return false;
    }

    // 确保按钮点击成功的函数
    async function ensureButtonClick(button) {
        let attempts = 0;
        const maxAttempts = 3; // 设置最大尝试次数
        let clicked = false;

        while (attempts < maxAttempts && !clicked) {
            button.click();
            console.log(`已点击按钮: ${button.innerText}，第 ${attempts + 1} 次尝试`);

            // 检查点击是否成功（这里假设按钮在点击后会有某种变化，比如消失或状态变化）
            await randomDelay(500, 1000); // 等待短暂时间以检测变化

            // 重新获取按钮的状态，如果已点击的按钮没有变化，继续尝试
            if (button.offsetParent === null || button.disabled) {
                clicked = true;
                console.log(`${button.innerText} 按钮点击成功`);
            } else {
                console.log(`${button.innerText} 按钮点击未成功，重试...`);
                attempts++;
            }
        }

        if (!clicked) {
            console.error(`${button.innerText} 按钮点击失败，超过最大尝试次数`);
        }
    }

    // 全局查找并点击 "CONTINUE" 按钮
    async function waitForAndClickContinue() {
        try {
            let continueButton;
            let attempts = 0;
            const maxAttempts = 10;  // 设置最大尝试次数

            while (attempts < maxAttempts) {
                attempts++;
                console.log(`尝试查找 "CONTINUE" 按钮，尝试次数: ${attempts}`);

                continueButton = Array.from(document.querySelectorAll('button')).find(button => button.innerText.toUpperCase() === 'CONTINUE');
                
                if (continueButton && continueButton.offsetParent !== null) {
                    console.log('点击 "CONTINUE" 按钮');
                    continueButton.click();
                    await randomDelay(1000, 3000);  // 点击后添加延迟
                    break;  // 成功点击后退出循环
                } else {
                    console.log(`"CONTINUE" 按钮未找到，等待后重试...`);
                    await randomDelay(5000, 10000);  // 每次点击后增加延迟
                }
            }

            if (!continueButton) {
                console.error('未能找到 "CONTINUE" 按钮，超出重试次数');
            }
        } catch (error) {
            console.error('查找 "CONTINUE" 按钮时出错', error);
        }
    }

    // 循环处理具有特定 class 的元素并只点击中央显示的元素
    async function loopThroughDivs() {
        const divs = Array.from(document.querySelectorAll('div.py-3.sm\\:py-4.px-5'));  // 查找指定 class 的 div
        if (divs.length === 0) {
            console.error('未找到符合条件的 div');
            return;
        }

        for (let div of divs) {
            if (!isElementInExactCenter(div)) {
                console.log('跳过不在严格中央的 div...');
                continue;
            }

            console.log('找到位于中央的 div，开始处理其中的按钮...');
            const buttons = Array.from(div.querySelectorAll('button'));

            for (let button of buttons) {
                if (buttonClickCount >= 3) {
                    console.log('已点击3个按钮但未触发窗口，点击备用元素...');
                    const backupElement = await waitForElementVisible('//*[@id="social-quests"]/div[1]/div/div[2]/div[2]');
                    if (backupElement) {
                        backupElement.click();
                        console.log('点击了备用元素');
                        await randomDelay(1000, 3000);  // 添加延迟
                        buttonClickCount = 0; // 重置点击计数
                    }
                    break;
                }

                console.log(`点击按钮: ${button.innerText}`);
                button.click();
                buttonClickCount++;
                await randomDelay(1000, 3000);  // 点击后添加延迟

                // 检查是否弹出小窗口
                const popupAppeared = await handlePopup();
                if (popupAppeared) {
                    buttonClickCount = 0; // 如果弹出小窗口，重置计数
                }
            }
        }
    }

    // 启动主流程
    async function mainProcess() {
        console.log('开始执行第二区域的脚本...');
        await randomDelay(3000, 5000);  // 初始延迟

        await clickFirstElement();  // 点击第一个元素

        while (loopCount < 5) {
            console.log(`开始执行第 ${loopCount + 1} 次循环...`);
            await loopThroughDivs();  // 进入循环处理 div
            loopCount++;
        }

        console.log('脚本执行结束。');
    }

    // 页面加载完成后启动脚本
    window.addEventListener('load', mainProcess);

})();
